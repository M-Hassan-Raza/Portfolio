<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Optimizing Django Signals for Efficient Ledger Recalculations | Muhammad Hassan Raza</title>
<meta name=keywords content="Django,Performance,Ledger,Optimization"><meta name=description content="Introduction
When dealing with financial transactions in Django applications, maintaining an accurate ledger is critical. However, inefficient signal handling can lead to performance bottlenecks. In this article, we&rsquo;ll explore an optimized approach to recalculating ledger balances while ensuring minimal database impact.
The Problem
A typical ledger system requires recalculating balances when transactions are inserted, updated, or deleted. Using Django signals, many implementations trigger redundant recalculations, causing excessive database queries and slowing down the application."><meta name=author content="Muhammad Hassan Raza"><link rel=canonical href=https://mhassan.dev/blog/using-signals-optimally/><link crossorigin=anonymous href=/assets/css/stylesheet.a81e2e0c3c85c6db8d548e00b35edf59505ce2cb1694cf1bd7b7120b42aee996.css integrity="sha256-qB4uDDyFxtuNVI4As17fWVBc4ssWlM8b17cSC0Ku6ZY=" rel="preload stylesheet" as=style><link rel=icon href=https://mhassan.dev/assets/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://mhassan.dev/assets/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://mhassan.dev/assets/favicon.svg><link rel=apple-touch-icon href=https://mhassan.dev/apple-touch-icon.png><link rel=mask-icon href=https://mhassan.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mhassan.dev/blog/using-signals-optimally/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/extended/extended.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/fonts/font-family.css><script async src=https://cloud.umami.is/script.js data-website-id=30c7d9d6-abac-4c52-b85a-c0234f863d22></script><meta property="og:url" content="https://mhassan.dev/blog/using-signals-optimally/"><meta property="og:site_name" content="Muhammad Hassan Raza"><meta property="og:title" content="Optimizing Django Signals for Efficient Ledger Recalculations"><meta property="og:description" content="Introduction When dealing with financial transactions in Django applications, maintaining an accurate ledger is critical. However, inefficient signal handling can lead to performance bottlenecks. In this article, we’ll explore an optimized approach to recalculating ledger balances while ensuring minimal database impact.
The Problem A typical ledger system requires recalculating balances when transactions are inserted, updated, or deleted. Using Django signals, many implementations trigger redundant recalculations, causing excessive database queries and slowing down the application."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-15T12:00:00+05:00"><meta property="article:modified_time" content="2025-02-15T12:00:00+05:00"><meta property="article:tag" content="Django"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Ledger"><meta property="article:tag" content="Optimization"><meta property="og:image" content="https://mhassan.dev/assets/ledger-opt.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mhassan.dev/assets/ledger-opt.jpg"><meta name=twitter:title content="Optimizing Django Signals for Efficient Ledger Recalculations"><meta name=twitter:description content="Introduction
When dealing with financial transactions in Django applications, maintaining an accurate ledger is critical. However, inefficient signal handling can lead to performance bottlenecks. In this article, we&rsquo;ll explore an optimized approach to recalculating ledger balances while ensuring minimal database impact.
The Problem
A typical ledger system requires recalculating balances when transactions are inserted, updated, or deleted. Using Django signals, many implementations trigger redundant recalculations, causing excessive database queries and slowing down the application."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://mhassan.dev/blog/"},{"@type":"ListItem","position":2,"name":"Optimizing Django Signals for Efficient Ledger Recalculations","item":"https://mhassan.dev/blog/using-signals-optimally/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Optimizing Django Signals for Efficient Ledger Recalculations","name":"Optimizing Django Signals for Efficient Ledger Recalculations","description":"Introduction When dealing with financial transactions in Django applications, maintaining an accurate ledger is critical. However, inefficient signal handling can lead to performance bottlenecks. In this article, we\u0026rsquo;ll explore an optimized approach to recalculating ledger balances while ensuring minimal database impact.\nThe Problem A typical ledger system requires recalculating balances when transactions are inserted, updated, or deleted. Using Django signals, many implementations trigger redundant recalculations, causing excessive database queries and slowing down the application.\n","keywords":["Django","Performance","Ledger","Optimization"],"articleBody":"Introduction When dealing with financial transactions in Django applications, maintaining an accurate ledger is critical. However, inefficient signal handling can lead to performance bottlenecks. In this article, we’ll explore an optimized approach to recalculating ledger balances while ensuring minimal database impact.\nThe Problem A typical ledger system requires recalculating balances when transactions are inserted, updated, or deleted. Using Django signals, many implementations trigger redundant recalculations, causing excessive database queries and slowing down the application.\nCommon Issues with Signals: Unnecessary Queries: Each save or delete operation triggers a recalculation, even if no meaningful change occurs. Cascade Effects: Bulk operations lead to multiple redundant recalculations. Performance Overhead: Large transaction volumes cause significant slowdowns. Optimized Approach To address these inefficiencies, we introduce a flag-based recalculation strategy that minimizes unnecessary database interactions.\nStep 1: Adding a Recalculation Flag Instead of recalculating every time a transaction is saved, we introduce a _needs_recalc flag:\nfrom django.db import models from django.db.models.signals import post_save, post_delete from django.dispatch import receiver class Transaction(models.Model): amount = models.DecimalField(max_digits=10, decimal_places=2) ledger = models.ForeignKey('Ledger', on_delete=models.CASCADE) def save(self, *args, **kwargs): self.ledger._needs_recalc = True super().save(*args, **kwargs) @receiver(post_delete, sender=Transaction) def mark_ledger_for_recalc(sender, instance, **kwargs): instance.ledger._needs_recalc = True Step 2: Efficient Ledger Recalculation Recalculating balances should only occur when necessary, ideally after all related operations are complete:\nfrom django.db import transaction def recalculate_ledger_balances(): ledgers_to_update = Ledger.objects.filter(_needs_recalc=True) for ledger in ledgers_to_update: ledger.recalculate_balance() ledger._needs_recalc = False ledger.save(update_fields=['balance']) Step 3: Using Post-Transaction Hooks Using Django’s on_commit() ensures recalculations only happen after successful transactions:\nfrom django.db.transaction import on_commit @receiver(post_save, sender=Transaction) def trigger_ledger_recalc(sender, instance, **kwargs): on_commit(lambda: recalculate_ledger_balances()) Performance Gains With this approach, we achieve:\nReduced Queries: Recalculation happens once per affected ledger, not per transaction. Better Scalability: Batch updates improve efficiency. Consistent Data: Using on_commit() ensures recalculations only happen after successful writes. Conclusion By intelligently managing recalculations, we significantly improve the performance of our ledger system in Django applications. This approach ensures efficiency without sacrificing data accuracy, making it ideal for high-volume financial applications.\n","wordCount":"320","inLanguage":"en","image":"https://mhassan.dev/assets/ledger-opt.jpg","datePublished":"2025-02-15T12:00:00+05:00","dateModified":"2025-02-15T12:00:00+05:00","author":{"@type":"Person","name":"Muhammad Hassan Raza"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mhassan.dev/blog/using-signals-optimally/"},"publisher":{"@type":"Organization","name":"Muhammad Hassan Raza","logo":{"@type":"ImageObject","url":"https://mhassan.dev/assets/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mhassan.dev/ accesskey=h title="Muhammad Hassan Raza (Alt + H)">Muhammad Hassan Raza</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mhassan.dev/about/ title=About><span><svg class="menu-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21v-2a4 4 0 00-4-4H9a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>About</span></a></li><li><a href=https://mhassan.dev/projects/ title=Projects><span><svg class="menu-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5A2 2 0 003 7z"/></svg>Projects</span></a></li><li><a href=https://mhassan.dev/blog/ title=Blog><span><svg class="menu-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3H5A2 2 0 003 5v14a2 2 0 002 2h14a2 2 0 002-2v-7"/><path d="M18.375 2.625a2.121 2.121.0 113 3L12 15l-4 1 1-4z"/></svg>Blog</span></a></li><li><a href=https://mhassan.dev/search/ title="Search (Alt + /)" accesskey=/><span><svg class="menu-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>Search</span></a></li><li><a href=https://mhassan.dev/books/ title="Books I've Read"><span>Books I've Read</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mhassan.dev/>Home</a>&nbsp;»&nbsp;<a href=https://mhassan.dev/blog/>Blog</a></div><h1 class=post-title>Optimizing Django Signals for Efficient Ledger Recalculations</h1><div class=post-meta><span title='2025-02-15 12:00:00 +0500 +0500'>February 15, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Muhammad Hassan Raza</div></header><figure class=entry-cover><img loading=lazy src=https://mhassan.dev/assets/ledger-opt.jpg alt="Ledger Optimization"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#the-problem aria-label="The Problem">The Problem</a><ul><li><a href=#common-issues-with-signals aria-label="Common Issues with Signals:">Common Issues with Signals:</a></li></ul></li><li><a href=#optimized-approach aria-label="Optimized Approach">Optimized Approach</a><ul><li><a href=#step-1-adding-a-recalculation-flag aria-label="Step 1: Adding a Recalculation Flag">Step 1: Adding a Recalculation Flag</a></li><li><a href=#step-2-efficient-ledger-recalculation aria-label="Step 2: Efficient Ledger Recalculation">Step 2: Efficient Ledger Recalculation</a></li><li><a href=#step-3-using-post-transaction-hooks aria-label="Step 3: Using Post-Transaction Hooks">Step 3: Using Post-Transaction Hooks</a></li></ul></li><li><a href=#performance-gains aria-label="Performance Gains">Performance Gains</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>When dealing with financial transactions in Django applications, maintaining an accurate ledger is critical. However, inefficient signal handling can lead to performance bottlenecks. In this article, we&rsquo;ll explore an optimized approach to recalculating ledger balances while ensuring minimal database impact.</p><h2 id=the-problem>The Problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h2><p>A typical ledger system requires recalculating balances when transactions are inserted, updated, or deleted. Using Django signals, many implementations trigger redundant recalculations, causing excessive database queries and slowing down the application.</p><h3 id=common-issues-with-signals>Common Issues with Signals:<a hidden class=anchor aria-hidden=true href=#common-issues-with-signals>#</a></h3><ul><li><strong>Unnecessary Queries</strong>: Each save or delete operation triggers a recalculation, even if no meaningful change occurs.</li><li><strong>Cascade Effects</strong>: Bulk operations lead to multiple redundant recalculations.</li><li><strong>Performance Overhead</strong>: Large transaction volumes cause significant slowdowns.</li></ul><h2 id=optimized-approach>Optimized Approach<a hidden class=anchor aria-hidden=true href=#optimized-approach>#</a></h2><p>To address these inefficiencies, we introduce a flag-based recalculation strategy that minimizes unnecessary database interactions.</p><h3 id=step-1-adding-a-recalculation-flag>Step 1: Adding a Recalculation Flag<a hidden class=anchor aria-hidden=true href=#step-1-adding-a-recalculation-flag>#</a></h3><p>Instead of recalculating every time a transaction is saved, we introduce a <code>_needs_recalc</code> flag:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> django.db <span style=color:#f92672>import</span> models
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.db.models.signals <span style=color:#f92672>import</span> post_save, post_delete
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.dispatch <span style=color:#f92672>import</span> receiver
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Transaction</span>(models<span style=color:#f92672>.</span>Model):
</span></span><span style=display:flex><span>    amount <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>DecimalField(max_digits<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>, decimal_places<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    ledger <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>ForeignKey(<span style=color:#e6db74>&#39;Ledger&#39;</span>, on_delete<span style=color:#f92672>=</span>models<span style=color:#f92672>.</span>CASCADE)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>save</span>(self, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>ledger<span style=color:#f92672>.</span>_needs_recalc <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>save(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@receiver</span>(post_delete, sender<span style=color:#f92672>=</span>Transaction)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>mark_ledger_for_recalc</span>(sender, instance, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>    instance<span style=color:#f92672>.</span>ledger<span style=color:#f92672>.</span>_needs_recalc <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><h3 id=step-2-efficient-ledger-recalculation>Step 2: Efficient Ledger Recalculation<a hidden class=anchor aria-hidden=true href=#step-2-efficient-ledger-recalculation>#</a></h3><p>Recalculating balances should only occur when necessary, ideally after all related operations are complete:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> django.db <span style=color:#f92672>import</span> transaction
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>recalculate_ledger_balances</span>():
</span></span><span style=display:flex><span>    ledgers_to_update <span style=color:#f92672>=</span> Ledger<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(_needs_recalc<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ledger <span style=color:#f92672>in</span> ledgers_to_update:
</span></span><span style=display:flex><span>        ledger<span style=color:#f92672>.</span>recalculate_balance()
</span></span><span style=display:flex><span>        ledger<span style=color:#f92672>.</span>_needs_recalc <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        ledger<span style=color:#f92672>.</span>save(update_fields<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#39;balance&#39;</span>])
</span></span></code></pre></div><h3 id=step-3-using-post-transaction-hooks>Step 3: Using Post-Transaction Hooks<a hidden class=anchor aria-hidden=true href=#step-3-using-post-transaction-hooks>#</a></h3><p>Using Django’s <code>on_commit()</code> ensures recalculations only happen after successful transactions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> django.db.transaction <span style=color:#f92672>import</span> on_commit
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@receiver</span>(post_save, sender<span style=color:#f92672>=</span>Transaction)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>trigger_ledger_recalc</span>(sender, instance, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>    on_commit(<span style=color:#66d9ef>lambda</span>: recalculate_ledger_balances())
</span></span></code></pre></div><h2 id=performance-gains>Performance Gains<a hidden class=anchor aria-hidden=true href=#performance-gains>#</a></h2><p>With this approach, we achieve:</p><ul><li><strong>Reduced Queries</strong>: Recalculation happens once per affected ledger, not per transaction.</li><li><strong>Better Scalability</strong>: Batch updates improve efficiency.</li><li><strong>Consistent Data</strong>: Using <code>on_commit()</code> ensures recalculations only happen after successful writes.</li></ul><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>By intelligently managing recalculations, we significantly improve the performance of our ledger system in Django applications. This approach ensures efficiency without sacrificing data accuracy, making it ideal for high-volume financial applications.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://mhassan.dev/tags/django>Django</a></li><li><a href=https://mhassan.dev/tags/performance>Performance</a></li><li><a href=https://mhassan.dev/tags/ledger>Ledger</a></li><li><a href=https://mhassan.dev/tags/optimization>Optimization</a></li></ul><nav class=paginav><a class=prev href=https://mhassan.dev/blog/free-website-hosting/><span class=title>« Prev</span><br><span>How I Built My Portfolio Website with Hugo, GitHub Pages, and Free Tools</span>
</a><a class=next href=https://mhassan.dev/blog/reusing-components-benefits/><span class=title>Next »</span><br><span>The Importance of Reusable Components for Critical Actions in VueJS</span></a></nav></footer><div class=giscus-container><script src=https://giscus.app/client.js data-repo=M-Hassan-Raza/Portfolio data-repo-id=R_kgDON3Oajw data-category=General data-category-id=DIC_kwDON3Oaj84Cm3y9 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://mhassan.dev/>Muhammad Hassan Raza</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>