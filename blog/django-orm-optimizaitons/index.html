<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Optimizing Django ORM Queries for Large Applications | Muhammad Hassan Raza</title>
<meta name=keywords content="Django,Performance,Database Optimization,ORM"><meta name=description content="Introduction
As my POS system scaled, performance bottlenecks became increasingly apparent. Customers began complaining about slow bill generation times, which made checkout frustratingly sluggish. After profiling my Django APIs, I discovered that inefficient ORM queries were causing unnecessary database overhead, leading to significant slowdowns. This prompted a deep dive into ORM optimizations to reduce query execution time and improve the overall user experience.
In this post, I&rsquo;ll share how I optimized my Django ORM queries using select_related, prefetch_related, bulk operations, and query profiling tools to enhance the efficiency of my refund API and bill generation process."><meta name=author content="Muhammad Hassan Raza"><link rel=canonical href=https://mhassan.dev/blog/django-orm-optimizaitons/><link crossorigin=anonymous href=/assets/css/stylesheet.09d62edb81e5f83e4dcca57744805cf0b5e1b7dd8d900687b4757fed831e251f.css integrity="sha256-CdYu24Hl+D5NzKV3RIBc8LXht92NkAaHtHV/7YMeJR8=" rel="preload stylesheet" as=style><link rel=icon href=https://mhassan.dev/assets/favicon.svg><link rel=icon type=image/png sizes=16x16 href=https://mhassan.dev/assets/favicon.svg><link rel=icon type=image/png sizes=32x32 href=https://mhassan.dev/assets/favicon.svg><link rel=apple-touch-icon href=https://mhassan.dev/apple-touch-icon.png><link rel=mask-icon href=https://mhassan.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mhassan.dev/blog/django-orm-optimizaitons/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preload href=/css/extended/extended.css as=style><link rel=stylesheet href=/css/extended/extended.css><link rel=preload href=/fonts/font-family.css as=style><link rel=stylesheet href=/fonts/font-family.css><link rel=preload href=/fonts/Manrope-Regular.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/Manrope-Medium.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/Manrope-Bold.woff2 as=font type=font/woff2 crossorigin><script async src=https://cloud.umami.is/script.js data-website-id=30c7d9d6-abac-4c52-b85a-c0234f863d22></script><meta property="og:url" content="https://mhassan.dev/blog/django-orm-optimizaitons/"><meta property="og:site_name" content="Muhammad Hassan Raza"><meta property="og:title" content="Optimizing Django ORM Queries for Large Applications"><meta property="og:description" content="Introduction As my POS system scaled, performance bottlenecks became increasingly apparent. Customers began complaining about slow bill generation times, which made checkout frustratingly sluggish. After profiling my Django APIs, I discovered that inefficient ORM queries were causing unnecessary database overhead, leading to significant slowdowns. This prompted a deep dive into ORM optimizations to reduce query execution time and improve the overall user experience.
In this post, I’ll share how I optimized my Django ORM queries using select_related, prefetch_related, bulk operations, and query profiling tools to enhance the efficiency of my refund API and bill generation process."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-17T12:00:00+05:00"><meta property="article:modified_time" content="2025-02-17T12:00:00+05:00"><meta property="article:tag" content="Django"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Database Optimization"><meta property="article:tag" content="ORM"><meta property="og:image" content="https://mhassan.dev/assets/django-orm.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mhassan.dev/assets/django-orm.jpg"><meta name=twitter:title content="Optimizing Django ORM Queries for Large Applications"><meta name=twitter:description content="Introduction
As my POS system scaled, performance bottlenecks became increasingly apparent. Customers began complaining about slow bill generation times, which made checkout frustratingly sluggish. After profiling my Django APIs, I discovered that inefficient ORM queries were causing unnecessary database overhead, leading to significant slowdowns. This prompted a deep dive into ORM optimizations to reduce query execution time and improve the overall user experience.
In this post, I&rsquo;ll share how I optimized my Django ORM queries using select_related, prefetch_related, bulk operations, and query profiling tools to enhance the efficiency of my refund API and bill generation process."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blog","item":"https://mhassan.dev/blog/"},{"@type":"ListItem","position":2,"name":"Optimizing Django ORM Queries for Large Applications","item":"https://mhassan.dev/blog/django-orm-optimizaitons/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Optimizing Django ORM Queries for Large Applications","name":"Optimizing Django ORM Queries for Large Applications","description":"Introduction As my POS system scaled, performance bottlenecks became increasingly apparent. Customers began complaining about slow bill generation times, which made checkout frustratingly sluggish. After profiling my Django APIs, I discovered that inefficient ORM queries were causing unnecessary database overhead, leading to significant slowdowns. This prompted a deep dive into ORM optimizations to reduce query execution time and improve the overall user experience.\nIn this post, I\u0026rsquo;ll share how I optimized my Django ORM queries using select_related, prefetch_related, bulk operations, and query profiling tools to enhance the efficiency of my refund API and bill generation process.\n","keywords":["Django","Performance","Database Optimization","ORM"],"articleBody":"Introduction As my POS system scaled, performance bottlenecks became increasingly apparent. Customers began complaining about slow bill generation times, which made checkout frustratingly sluggish. After profiling my Django APIs, I discovered that inefficient ORM queries were causing unnecessary database overhead, leading to significant slowdowns. This prompted a deep dive into ORM optimizations to reduce query execution time and improve the overall user experience.\nIn this post, I’ll share how I optimized my Django ORM queries using select_related, prefetch_related, bulk operations, and query profiling tools to enhance the efficiency of my refund API and bill generation process.\nThe N+1 Query Problem and Its Impact One major issue I faced was the N+1 query problem, which happens when querying related objects in a loop, leading to excessive database hits.\nFor example, in my refund API:\nfor item_data in refund_items_data: bill_item = BillItem.objects.get(id=item_data[\"bill_item_id\"]) product = bill_item.product # This triggers a separate query each time Since each iteration fetched a related product separately, it resulted in multiple queries—one for each bill_item. When processing large refunds, this approach led to severe slowdowns.\nSolution: Using select_related for ForeignKey Joins Replacing individual lookups with select_related drastically reduced query counts by using SQL joins to fetch related data in a single query:\nfor item_data in refund_items_data: bill_item = BillItem.objects.select_related('product').get(id=item_data[\"bill_item_id\"]) product = bill_item.product # Now fetched in the same query This improved performance by minimizing redundant database hits.\nOptimizing Many-to-Many Queries with prefetch_related Another issue arose when fetching refund items along with related bill_items and products. Since Django’s ORM performs multiple queries for Many-to-Many relationships, prefetch_related was a better choice than select_related.\nrefund_items = RefundItem.objects.prefetch_related('bill_item__product').filter(refund=refund) This preloads related objects efficiently, reducing database queries and improving response times.\nWhen to Use Raw SQL vs. Django ORM Django ORM is powerful, but sometimes raw SQL is necessary for complex aggregations. For instance, if I needed to sum refunded amounts efficiently, a raw SQL query would outperform multiple ORM calls:\nfrom django.db import connection def get_total_refunded_amount(refund_id): with connection.cursor() as cursor: cursor.execute(\"\"\" SELECT SUM(refunded_amount) FROM refund_item WHERE refund_id = %s \"\"\", [refund_id]) return cursor.fetchone()[0] This direct approach was faster than filtering and aggregating with Django ORM in certain scenarios.\nEfficient Bulk Inserts and Updates Handling refunds involved updating multiple products at once. Initially, I updated each product inside a loop, leading to excessive database writes:\nfor product in products_to_update: product.save() Switching to bulk_update allowed batch updates, significantly improving performance:\nProduct.objects.bulk_update(products_to_update, [\"quantity_units\", \"quantity_subunits\"]) Similarly, bulk_create was useful for inserting multiple refund items efficiently:\nRefundItem.objects.bulk_create(refund_items) Profiling Queries with Django Debug Toolbar and Silk To identify bottlenecks, I used Django Debug Toolbar and Silk:\nDjango Debug Toolbar\nInstalled via: pip install django-debug-toolbar Added to INSTALLED_APPS and middleware, it revealed query counts and execution times. Silk\nInstalled via: pip install django-silk Enabled query logging, helping me pinpoint slow database operations. These tools were invaluable in detecting inefficient queries and refining my ORM usage.\nResults and Performance Gains After implementing these optimizations, the refund API saw a 70% reduction in query execution time, significantly improving bill generation speed. Customers immediately noticed smoother transactions, and complaints about slow processing vanished.\nConclusion Optimizing Django ORM queries is crucial for scaling large applications. By leveraging select_related, prefetch_related, bulk operations, and profiling tools, I was able to fine-tune my APIs for high performance. If you’re experiencing slow database operations, consider these strategies to improve efficiency and responsiveness in your Django projects. These techniques ended up saving my business from potential losses (customer were fuming a little ngl) due to poor user experience, and I’m confident they can help you too.\n","wordCount":"588","inLanguage":"en","image":"https://mhassan.dev/assets/django-orm.jpg","datePublished":"2025-02-17T12:00:00+05:00","dateModified":"2025-02-17T12:00:00+05:00","author":{"@type":"Person","name":"Muhammad Hassan Raza"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mhassan.dev/blog/django-orm-optimizaitons/"},"publisher":{"@type":"Organization","name":"Muhammad Hassan Raza","logo":{"@type":"ImageObject","url":"https://mhassan.dev/assets/favicon.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mhassan.dev/ accesskey=h title="Muhammad Hassan Raza (Alt + H)">Muhammad Hassan Raza</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mhassan.dev/book-a-call/ title="Book a Call"><span><svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M8.26 1.289l-1.564.772c-5.793 3.02 2.798 20.944 9.31 20.944.46.0.904-.094 1.317-.284l1.542-.755-2.898-5.594-1.54.754c-.181.087-.384.134-.597.134-2.561.0-6.841-8.204-4.241-9.596l1.546-.763L8.26 1.289zM16.006 24C10.326 24 3.785 12.886 3.785 6.168c0-2.419.833-4.146 2.457-4.992l2.382-1.176 3.857 7.347-2.437 1.201c-1.439.772 2.409 8.424 3.956 7.68l2.399-1.179 3.816 7.36s-2.36 1.162-2.476 1.215c-.547.251-1.129.376-1.733.376"/></svg>Book a Call</span></a></li><li><a href=https://mhassan.dev/projects/ title=Projects><span><svg class="menu-icon" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5h13v17H0V2h8l3 3zM1 3v18h22V6H10.586l-3-3H1z"/></svg>Projects</span></a></li><li><a href=https://mhassan.dev/about/ title=About><span><svg class="menu-icon" shape-rendering="geometricPrecision" viewBox="-1 0 24 24" fill="none" stroke="currentcolor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M12 0c6.623.0 12 5.377 12 12s-5.377 12-12 12S0 18.623.0 12 5.377.0 12 0zm8.127 19.41c-.282-.401-.772-.654-1.624-.85-3.848-.906-4.097-1.501-4.352-2.059-.259-.565-.19-1.23.205-1.977 1.726-3.257 2.09-6.024 1.027-7.79C14.709 5.615 13.508 5 12 5c-1.521.0-2.732.626-3.409 1.763-1.066 1.789-.693 4.544 1.049 7.757.402.742.476 1.406.22 1.974-.265.586-.611 1.19-4.365 2.066-.852.196-1.342.449-1.623.848C5.884 21.615 8.782 23 12 23s6.115-1.385 8.127-3.59zm.65-.782C22.172 16.784 23 14.488 23 12c0-6.071-4.929-11-11-11S1 5.929 1 12c0 2.487.827 4.783 2.222 6.626.409-.452 1.049-.81 2.049-1.041 2.025-.462 3.376-.836 3.678-1.502.122-.272.061-.628-.188-1.087-1.917-3.535-2.282-6.641-1.03-8.745C8.584 4.82 10.139 4 12 4c1.845.0 3.391.808 4.24 2.218 1.251 2.079.896 5.195-1 8.774-.245.463-.304.821-.179 1.094.305.668 1.644 1.038 3.667 1.499 1 .23 1.64.59 2.049 1.043z"/></svg>About</span></a></li><li><a href=https://mhassan.dev/search/ title="Search (Alt + /)" accesskey=/><span><svg class="menu-icon" shape-rendering="geometricPrecision" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M15.853 16.56C14.17 18.077 11.942 19 9.5 19 4.257 19 0 14.743.0 9.5S4.257.0 9.5.0 19 4.257 19 9.5c0 2.442-.923 4.67-2.44 6.353l7.44 7.44-.707.707-7.44-7.44zm-6.353-15.56c4.691.0 8.5 3.809 8.5 8.5S14.191 18 9.5 18 1 14.191 1 9.5 4.809 1 9.5 1z"/></svg>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mhassan.dev/>Home</a>&nbsp;»&nbsp;<a href=https://mhassan.dev/blog/>Blog</a></div><h1 class=post-title>Optimizing Django ORM Queries for Large Applications</h1><div class=post-meta><span title='2025-02-17 12:00:00 +0500 +0500'>February 17, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Muhammad Hassan Raza</div></header><figure class=entry-cover><img loading=lazy src=https://mhassan.dev/assets/django-orm.jpg alt="Django ORM Optimization"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#the-n1-query-problem-and-its-impact aria-label="The N+1 Query Problem and Its Impact">The N+1 Query Problem and Its Impact</a><ul><li><a href=#solution-using-select_related-for-foreignkey-joins aria-label="Solution: Using select_related for ForeignKey Joins">Solution: Using select_related for ForeignKey Joins</a></li></ul></li><li><a href=#optimizing-many-to-many-queries-with-prefetch_related aria-label="Optimizing Many-to-Many Queries with prefetch_related">Optimizing Many-to-Many Queries with prefetch_related</a></li><li><a href=#when-to-use-raw-sql-vs-django-orm aria-label="When to Use Raw SQL vs. Django ORM">When to Use Raw SQL vs. Django ORM</a></li><li><a href=#efficient-bulk-inserts-and-updates aria-label="Efficient Bulk Inserts and Updates">Efficient Bulk Inserts and Updates</a></li><li><a href=#profiling-queries-with-django-debug-toolbar-and-silk aria-label="Profiling Queries with Django Debug Toolbar and Silk">Profiling Queries with Django Debug Toolbar and Silk</a></li><li><a href=#results-and-performance-gains aria-label="Results and Performance Gains">Results and Performance Gains</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>As my POS system scaled, performance bottlenecks became increasingly apparent. Customers began complaining about slow bill generation times, which made checkout frustratingly sluggish. After profiling my Django APIs, I discovered that inefficient ORM queries were causing unnecessary database overhead, leading to significant slowdowns. This prompted a deep dive into ORM optimizations to reduce query execution time and improve the overall user experience.</p><p>In this post, I&rsquo;ll share how I optimized my Django ORM queries using <code>select_related</code>, <code>prefetch_related</code>, bulk operations, and query profiling tools to enhance the efficiency of my refund API and bill generation process.</p><h2 id=the-n1-query-problem-and-its-impact>The N+1 Query Problem and Its Impact<a hidden class=anchor aria-hidden=true href=#the-n1-query-problem-and-its-impact>#</a></h2><p>One major issue I faced was the <strong>N+1 query problem</strong>, which happens when querying related objects in a loop, leading to excessive database hits.</p><p>For example, in my refund API:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> item_data <span style=color:#f92672>in</span> refund_items_data:
</span></span><span style=display:flex><span>    bill_item <span style=color:#f92672>=</span> BillItem<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>get(id<span style=color:#f92672>=</span>item_data[<span style=color:#e6db74>&#34;bill_item_id&#34;</span>])
</span></span><span style=display:flex><span>    product <span style=color:#f92672>=</span> bill_item<span style=color:#f92672>.</span>product  <span style=color:#75715e># This triggers a separate query each time</span>
</span></span></code></pre></div><p>Since each iteration fetched a related <code>product</code> separately, it resulted in multiple queries—one for each <code>bill_item</code>. When processing large refunds, this approach led to severe slowdowns.</p><h3 id=solution-using-select_related-for-foreignkey-joins>Solution: Using <code>select_related</code> for ForeignKey Joins<a hidden class=anchor aria-hidden=true href=#solution-using-select_related-for-foreignkey-joins>#</a></h3><p>Replacing individual lookups with <code>select_related</code> drastically reduced query counts by using SQL joins to fetch related data in a single query:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> item_data <span style=color:#f92672>in</span> refund_items_data:
</span></span><span style=display:flex><span>    bill_item <span style=color:#f92672>=</span> BillItem<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>select_related(<span style=color:#e6db74>&#39;product&#39;</span>)<span style=color:#f92672>.</span>get(id<span style=color:#f92672>=</span>item_data[<span style=color:#e6db74>&#34;bill_item_id&#34;</span>])
</span></span><span style=display:flex><span>    product <span style=color:#f92672>=</span> bill_item<span style=color:#f92672>.</span>product  <span style=color:#75715e># Now fetched in the same query</span>
</span></span></code></pre></div><p>This improved performance by minimizing redundant database hits.</p><h2 id=optimizing-many-to-many-queries-with-prefetch_related>Optimizing Many-to-Many Queries with <code>prefetch_related</code><a hidden class=anchor aria-hidden=true href=#optimizing-many-to-many-queries-with-prefetch_related>#</a></h2><p>Another issue arose when fetching refund items along with related <code>bill_items</code> and <code>products</code>. Since Django’s ORM performs multiple queries for Many-to-Many relationships, <code>prefetch_related</code> was a better choice than <code>select_related</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>refund_items <span style=color:#f92672>=</span> RefundItem<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>prefetch_related(<span style=color:#e6db74>&#39;bill_item__product&#39;</span>)<span style=color:#f92672>.</span>filter(refund<span style=color:#f92672>=</span>refund)
</span></span></code></pre></div><p>This preloads related objects efficiently, reducing database queries and improving response times.</p><h2 id=when-to-use-raw-sql-vs-django-orm>When to Use Raw SQL vs. Django ORM<a hidden class=anchor aria-hidden=true href=#when-to-use-raw-sql-vs-django-orm>#</a></h2><p>Django ORM is powerful, but sometimes raw SQL is necessary for complex aggregations. For instance, if I needed to sum refunded amounts efficiently, a raw SQL query would outperform multiple ORM calls:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> django.db <span style=color:#f92672>import</span> connection
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_total_refunded_amount</span>(refund_id):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> connection<span style=color:#f92672>.</span>cursor() <span style=color:#66d9ef>as</span> cursor:
</span></span><span style=display:flex><span>        cursor<span style=color:#f92672>.</span>execute(<span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            SELECT SUM(refunded_amount) FROM refund_item WHERE refund_id = </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;&#34;&#34;</span>, [refund_id])
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> cursor<span style=color:#f92672>.</span>fetchone()[<span style=color:#ae81ff>0</span>]
</span></span></code></pre></div><p>This direct approach was faster than filtering and aggregating with Django ORM in certain scenarios.</p><h2 id=efficient-bulk-inserts-and-updates>Efficient Bulk Inserts and Updates<a hidden class=anchor aria-hidden=true href=#efficient-bulk-inserts-and-updates>#</a></h2><p>Handling refunds involved updating multiple products at once. Initially, I updated each product inside a loop, leading to excessive database writes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> product <span style=color:#f92672>in</span> products_to_update:
</span></span><span style=display:flex><span>    product<span style=color:#f92672>.</span>save()
</span></span></code></pre></div><p>Switching to <code>bulk_update</code> allowed batch updates, significantly improving performance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Product<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>bulk_update(products_to_update, [<span style=color:#e6db74>&#34;quantity_units&#34;</span>, <span style=color:#e6db74>&#34;quantity_subunits&#34;</span>])
</span></span></code></pre></div><p>Similarly, <code>bulk_create</code> was useful for inserting multiple refund items efficiently:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>RefundItem<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>bulk_create(refund_items)
</span></span></code></pre></div><h2 id=profiling-queries-with-django-debug-toolbar-and-silk>Profiling Queries with Django Debug Toolbar and Silk<a hidden class=anchor aria-hidden=true href=#profiling-queries-with-django-debug-toolbar-and-silk>#</a></h2><p>To identify bottlenecks, I used <strong>Django Debug Toolbar</strong> and <strong>Silk</strong>:</p><ol><li><p><strong>Django Debug Toolbar</strong></p><ul><li>Installed via:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>pip install django-debug-toolbar
</span></span></code></pre></div></li><li>Added to <code>INSTALLED_APPS</code> and middleware, it revealed query counts and execution times.</li></ul></li><li><p><strong>Silk</strong></p><ul><li>Installed via:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>pip install django-silk
</span></span></code></pre></div></li><li>Enabled query logging, helping me pinpoint slow database operations.</li></ul></li></ol><p>These tools were invaluable in detecting inefficient queries and refining my ORM usage.</p><h2 id=results-and-performance-gains>Results and Performance Gains<a hidden class=anchor aria-hidden=true href=#results-and-performance-gains>#</a></h2><p>After implementing these optimizations, the refund API saw <strong>a 70% reduction in query execution time</strong>, significantly improving bill generation speed. Customers immediately noticed smoother transactions, and complaints about slow processing vanished.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Optimizing Django ORM queries is crucial for scaling large applications. By leveraging <code>select_related</code>, <code>prefetch_related</code>, bulk operations, and profiling tools, I was able to fine-tune my APIs for high performance. If you&rsquo;re experiencing slow database operations, consider these strategies to improve efficiency and responsiveness in your Django projects. These techniques ended up saving my business from potential losses (customer were fuming a little ngl) due to poor user experience, and I&rsquo;m confident they can help you too.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://mhassan.dev/tags/django>Django</a></li><li><a href=https://mhassan.dev/tags/performance>Performance</a></li><li><a href=https://mhassan.dev/tags/database-optimization>Database Optimization</a></li><li><a href=https://mhassan.dev/tags/orm>ORM</a></li></ul><nav class=paginav><a class=prev href=https://mhassan.dev/blog/fyp-guidance/><span class=title>« Prev</span><br><span>Final Year Project (FYP) Guide for Students</span>
</a><a class=next href=https://mhassan.dev/blog/free-website-hosting/><span class=title>Next »</span><br><span>How I Built My Portfolio Website with Hugo, GitHub Pages, and Free Tools</span></a></nav></footer><div class=giscus-container><script src=https://giscus.app/client.js data-repo=M-Hassan-Raza/Portfolio data-repo-id=R_kgDON3Oajw data-category=General data-category-id=DIC_kwDON3Oaj84Cm3y9 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=light data-lang=en crossorigin=anonymous async></script></div><script>function getTheme(){return document.body.classList.contains("dark")?"dark":"light"}function updateGiscusTheme(){const e=document.querySelector("iframe.giscus-frame");if(!e){setTimeout(updateGiscusTheme,300);return}const t=getTheme();e.contentWindow.postMessage({giscus:{setConfig:{theme:t}}},"https://giscus.app")}localStorage.getItem("pref-theme")==="dark"&&updateGiscusTheme();const observer=new MutationObserver(()=>{updateGiscusTheme()});observer.observe(document.body,{attributes:!0,attributeFilter:["class"]})</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://mhassan.dev/>Muhammad Hassan Raza</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>